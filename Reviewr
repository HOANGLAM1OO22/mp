Excellent ‚Äî this is exactly the kind of code review task that a senior engineer would do with reference to *Robert C. Martin‚Äôs* **Clean Code** principles.
Below is a **line-by-line review with inline comments and a summary for each code block (1 ‚Üí 5)**.
I‚Äôll use ‚úÖ (good), ‚ö†Ô∏è (minor issue), ‚ùå (problem), and üí° (improvement suggestion).

---

## üß© **Code 1 ‚Äî `Practice.BubbleSorter`**

```java
package Practice; // ‚ö†Ô∏è Package names should be lowercase per Java convention (e.g., 'practice')
```

```java
private double[] mArray = {}; // ‚ö†Ô∏è Avoid Hungarian notation (mArray). Use descriptive name like 'numbers' or 'array'
```

```java
public BubbleSorter(double[] array) {
    setArray(array); // ‚úÖ Constructor delegates initialization to setter (OK)
}
```

```java
public void setArray(double[] newArray) {
    this.mArray = newArray; // ‚ö†Ô∏è No validation (e.g., null/empty check)
}
```

```java
public void printArray() {
    for (double num : mArray) {
        System.out.print(num + " "); // ‚ö†Ô∏è IO inside core logic ‚Äî violates SRP (separation of concerns)
    }
    System.out.println();
}
```

```java
public void startSort() {
    printArray(); // ‚ö†Ô∏è Logging/printing should not be coupled to sorting
    sortArray();  // ‚úÖ Sorting delegated to private method
    printArray();
}
```

```java
private void sortArray() {
    int arrayLength = mArray.length; // ‚úÖ clear naming
    boolean isSwapped;
```

```java
for (int currentPass = 0; currentPass < arrayLength - 1; currentPass++) {
    isSwapped = false; // ‚úÖ Early-exit optimization available below
```

```java
for (int currentIndex = 0; currentIndex < arrayLength - currentPass - 1; currentIndex++) {
    if (shouldSwap(currentIndex)) { // ‚úÖ clear naming
        swap(currentIndex, currentIndex + 1);
        isSwapped = true;
    }
}
```

```java
if (!isSwapped) {
    break; // ‚úÖ early termination optimization
}
```

```java
private boolean shouldSwap(int index) {
    return mArray[index] > mArray[index + 1]; // ‚úÖ clear logic
}
```

```java
private void swap(int currentIndex, int nextIndex) {
    double temp = mArray[currentIndex]; // ‚úÖ simple and correct swap
    mArray[currentIndex] = mArray[nextIndex];
    mArray[nextIndex] = temp;
}
```

### **Summary (Code 1)**

‚úÖ **Pros:**

* Clear structure & separation of helper functions.
* Implements early exit (`isSwapped`) optimization.
* Simple & easy to understand.

‚ùå **Cons / Improvements:**

* Package and variable naming violate conventions (`Practice`, `mArray`).
* No validation for null/empty input.
* Printing logic should be removed from sorting logic.
* Hard-coded to `double[]` only ‚Üí no generic support.
* Missing unit tests or exception handling.

üí° **Clean version suggestion:**
‚Üí Extract IO (printing) into another class, validate input, rename identifiers, make it generic `<T extends Comparable<T>>`.

---

## üß© **Code 2 ‚Äî `cleancode3.bubblesort.BubbleSort`**

```java
public static final String ASCENDING_SORT = "ascending";
public static final String DESCENDING_SORT = "descending"; // ‚úÖ clear constants; could use enum instead
```

```java
public static void bubbleSort(int[] array, String sortOrder) {
    isValidSortOrder(sortOrder); // ‚ö†Ô∏è Method name implies validation but it throws ‚Üí rename to 'validateSortOrder'
```

```java
boolean elementsSwapped;
for (int currentPass = 0; currentPass < arraySize - 1; currentPass++) {
    elementsSwapped = false; // ‚úÖ reuse of early-exit optimization
```

```java
if (compareAndSwap(array, currentIndex, sortOrder)) {
    elementsSwapped = true; // ‚úÖ separation of comparison logic
}
```

```java
if (!elementsSwapped) break; // ‚úÖ efficient
```

```java
private static void isValidSortOrder(String sortOrder) {
    if (sortOrder == null || !ASCENDING_SORT.equalsIgnoreCase(sortOrder) && !DESCENDING_SORT.equalsIgnoreCase(sortOrder)) {
        throw new IllegalArgumentException("Invalid sort order..."); // ‚úÖ clear error message
    }
}
```

```java
private static boolean compareAndSwap(int[] array, int currentIndex, String sortOrder) {
    if (ASCENDING_SORT.equalsIgnoreCase(sortOrder)) {
        if (array[currentIndex] > array[currentIndex + 1]) { // ‚úÖ correct comparison
            swap(array, currentIndex);
            return true;
        }
    } else if (DESCENDING_SORT.equalsIgnoreCase(sortOrder)) {
        if (array[currentIndex] < array[currentIndex + 1]) {
            swap(array, currentIndex);
            return true;
        }
    }
    return false;
}
```

```java
private static void swap(int[] array, int currentIndex) { // ‚ö†Ô∏è Unclear method name ‚Äî ‚ÄòswapAdjacent‚Äô would be clearer
    int temp = array[currentIndex];
    array[currentIndex] = array[currentIndex + 1];
    array[currentIndex + 1] = temp;
}
```

### **Summary (Code 2)**

‚úÖ **Pros:**

* Proper input validation.
* Supports ascending and descending sorting.
* Separation of comparison, swap, and validation logic.
* Clean naming and good readability.

‚ùå **Cons:**

* `isValidSortOrder()` name misleading (throws exception ‚Üí should be `validateSortOrder`).
* Could use **enum** instead of string literals for safety.
* No generic type; fixed to `int[]`.
* No `null` array check.

üí° **Good step toward Clean Code ‚Äî structured, readable, single responsibility per method.**

---

## üß© **Code 3 ‚Äî `cleancode3.bubblesort.BubbleSorter` (Generic-like)**

```java
public static final String ASCENDING = "ascending";
public static final String DESCENDING = "descending"; // ‚úÖ consistent constants
```

```java
public static int[] bubbleSort(int[] array, String sortOrder) {
    validateSortOrder(sortOrder); // ‚úÖ validation before logic
    boolean isSorted;
    do {
        isSorted = true; // ‚úÖ clean do-while design instead of nested for
        ...
    } while (!isSorted);
}
```

```java
private static boolean shouldSwap(Number currentElement, Number nextElement, String sortOrder) {
    if (sortOrder.equals(ASCENDING)) {
        return currentElement.doubleValue() > nextElement.doubleValue(); // ‚úÖ clean abstraction using Number
    } else {
        return currentElement.doubleValue() < nextElement.doubleValue();
    }
}
```

```java
private static void swap(double[] array, int firstIndex, int secondIndex) { ... }
private static void swap(int[] array, int firstIndex, int secondIndex) { ... } // ‚úÖ Overloaded clean design
```

### **Summary (Code 3)**

‚úÖ **Pros:**

* Works for both `int[]` and `double[]`.
* Avoids code duplication using shared logic (`shouldSwap`).
* Uses validation properly.
* Separation of logic is clear.
* Do-while loop ensures repeat until sorted ‚Äî simpler control flow.

‚ùå **Cons:**

* Still uses `String` for sort order instead of enum.
* Lacks handling of `null` arrays.
* Slight duplication between two `bubbleSort` overloads.
* Conversion `doubleValue()` may cause small precision issues for very large `long` values.

üí° **Very close to Clean Code:** consistent naming, no side effects, low complexity.
‚úÖ **Best structured among the sorting codes.**

---

## üß© **Code 4 ‚Äî `cleancode3.BubbleSort` (Interactive console)**

```java
Scanner scanner = new Scanner(System.in); // ‚ö†Ô∏è IO handling inside main is OK but should not mix with logic
```

```java
public static void sort(int[] array, String directionOrder) {
    int arrayLength = array.length;
    String sortDirection = directionOrder.toLowerCase(); // ‚úÖ normalization
```

```java
performBubbleSortPass(array, sortDirection, arrayLength - i - 1); // ‚úÖ extracted helper improves readability
```

```java
private static boolean shouldSwapElements(int[] array, int index, String sortDirection) {
    if (sortDirection.contains("ascend")) { // ‚ö†Ô∏è fragile ‚Äî should be equalsIgnoreCase
        return array[index] > array[index + 1];
    } else {
        return array[index] < array[index + 1];
    }
}
```

```java
public static void sort(int[] array) {
    sort(array, "ascending"); // ‚úÖ overloaded default method
}
```

```java
private static boolean isValidDirection(String direction) {
    return "ascending".equals(direction) || "descending".equals(direction); // ‚úÖ validation
}
```

```java
private static void printArray(int[] array) {
    for (...) System.out.print(...); // ‚ö†Ô∏è console logic ‚Äî should be separated
}
```

### **Summary (Code 4)**

‚úÖ **Pros:**

* Clear, readable structure.
* Separation into helper methods (`performBubbleSortPass`, `shouldSwapElements`).
* Interactive user input handling with validation.
* Simple overloaded default `sort()`.

‚ùå **Cons:**

* Mixes user interaction (IO) with sorting logic (violates SRP).
* Weak comparison using `contains("ascend")` ‚Äî unsafe.
* No exception handling for invalid input (e.g., non-number).

üí° **Better for learning/demo, not for production.**
Should refactor into `Sorter` (logic) + `Main` (UI/CLI interaction).

---

## üß© **Code 5 ‚Äî `cleancode1.fitnesse.testablehtml.TestableHtml`**

```java
private static final String TEST_ATTRIBUTE = "Test"; // ‚úÖ Good constant naming
private static final String TEARDOWN_ATTRIBUTE = "TearDown"; // ‚úÖ consistent naming
```

```java
public String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {
    if (!isTestHtml(pageData)) {
        return pageData.getHtml(); // ‚úÖ clean early return
    }
```

```java
StringBuffer buffer = new StringBuffer(); // ‚ö†Ô∏è use StringBuilder instead (non-synchronized)
appendSetupIncludes(wikiPage, includeSuiteSetup, buffer); // ‚úÖ good method extraction
appendContent(pageData, buffer);
appendTeardownIncludes(wikiPage, includeSuiteSetup, buffer);
```

```java
pageData.setContent(buffer.toString());
return pageData.getHtml(); // ‚úÖ single responsibility and good composition
```

```java
private void appendSetupIncludes(...) { ... } // ‚úÖ decomposed logic
private void appendTeardownIncludes(...) { ... } // ‚úÖ good symmetry between setup/teardown
```

```java
private void appendInclude(StringBuffer buffer, String includeName, String pagePathName) throws Exception {
    buffer.append(includeName).append(pagePathName).append("\n"); // ‚ö†Ô∏è could extract a small IncludeFormatter class
}
```

```java
private boolean isTestHtml(PageData pageData) throws Exception {
    return pageData.hasAttribute(TEST_ATTRIBUTE); // ‚úÖ single purpose check
}
```

### **Summary (Code 5)**

‚úÖ **Pros:**

* Excellent adherence to *Clean Code*: short, cohesive methods.
* Consistent naming and separation of responsibilities.
* Clear early returns.
* Proper encapsulation of setup/teardown inclusion logic.

‚ö†Ô∏è **Minor improvements:**

* Replace `StringBuffer` with `StringBuilder`.
* Reduce `throws Exception` ‚Üí specify checked exceptions.
* Consider dependency inversion for include formatting.

üí° **Best overall code quality** ‚Äî likely written with Clean Code mindset.

---

# üßæ **Final Comparative Summary**

| Code                                    | Strengths                                    | Weaknesses                       | Clean Code Grade |
| --------------------------------------- | -------------------------------------------- | -------------------------------- | ---------------- |
| **1 ‚Äì Practice.BubbleSorter**           | Simple, readable                             | Naming, IO mixing, no validation | ‚ö†Ô∏è C             |
| **2 ‚Äì cleancode3.BubbleSort**           | Clear structure, validation, separation      | Hardcoded strings, fixed type    | ‚úÖ B              |
| **3 ‚Äì cleancode3.BubbleSorter**         | Generic-like, clean control, no side effects | String enums, no null check      | üåü **A-**        |
| **4 ‚Äì cleancode3.BubbleSort (console)** | Interactive, modular helpers                 | SRP violation (UI + logic)       | ‚ö†Ô∏è C+            |
| **5 ‚Äì TestableHtml**                    | Excellent decomposition, consistent naming   | Minor modernizations             | üåü **A**         |

---

Would you like me to produce a **GitHub review-style markdown file** (with diff comments and summary sections) suitable for a pull request review description?
