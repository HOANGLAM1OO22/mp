package com.example;

import android.content.Context;
import android.media.MediaCodec;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaCodec.Callback;
import android.media.MediaCodec.BufferInfo;
import android.os.Build;
import android.util.Log;

import androidx.annotation.RequiresApi;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public class PrintPTSCodecTest {

    private static final String TAG = "PTSCodec";

    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    @Test
    public void printPTS_UsingDecoderCallback() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();

        // TODO: Change this path
        String path = "/sdcard/test/input.mp4";

        MediaExtractor extractor = new MediaExtractor();
        extractor.setDataSource(path);

        int videoTrack = -1;
        MediaFormat videoFormat = null;

        for (int i = 0; i < extractor.getTrackCount(); i++) {
            MediaFormat fmt = extractor.getTrackFormat(i);
            String mime = fmt.getString(MediaFormat.KEY_MIME);
            if (mime.startsWith("video/")) {
                videoTrack = i;
                videoFormat = fmt;
                Log.i(TAG, "Found VIDEO track " + i + " " + mime);
                break;
            }
        }

        if (videoTrack < 0) {
            Log.e(TAG, "NO VIDEO TRACK FOUND");
            return;
        }

        extractor.selectTrack(videoTrack);

        CountDownLatch latch = new CountDownLatch(1);

        MediaCodec decoder = MediaCodec.createDecoderByType(
                videoFormat.getString(MediaFormat.KEY_MIME)
        );

        decoder.setCallback(new Callback() {

            int frameIndex = 0;
            boolean eosInput = false;

            @Override
            public void onInputBufferAvailable(MediaCodec codec, int index) {
                if (eosInput) return;

                ByteBuffer input = codec.getInputBuffer(index);
                if (input == null) return;

                int sampleSize = extractor.readSampleData(input, 0);
                if (sampleSize < 0) {
                    // EOS input
                    Log.i(TAG, "INPUT EOS");
                    codec.queueInputBuffer(index, 0, 0, 0,
                            MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                    eosInput = true;
                    return;
                }

                long pts = extractor.getSampleTime();

                codec.queueInputBuffer(
                        index,
                        0,
                        sampleSize,
                        pts,
                        extractor.getSampleFlags()
                );

                extractor.advance();
            }

            @Override
            public void onOutputBufferAvailable(MediaCodec codec, int index, BufferInfo info) {

                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                    codec.releaseOutputBuffer(index, false);
                    return;
                }

                if (info.size > 0) {
                    Log.i(TAG, "DECODED FRAME "
                            + " idx=" + frameIndex
                            + " pts=" + info.presentationTimeUs
                            + " size=" + info.size);

                    frameIndex++;
                }

                boolean eosOutput = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;
                codec.releaseOutputBuffer(index, false);

                if (eosOutput) {
                    Log.i(TAG, "OUTPUT EOS - totalFrames=" + frameIndex + ", lastPTS=" + info.presentationTimeUs);
                    latch.countDown();
                }
            }

            @Override
            public void onError(MediaCodec codec, MediaCodec.CodecException e) {
                Log.e(TAG, "DECODER ERROR", e);
                latch.countDown();
            }

            @Override
            public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {
                Log.i(TAG, "Format changed: " + format);
            }
        });

        decoder.configure(videoFormat, null, null, 0);
        decoder.start();

        latch.await(10, TimeUnit.SECONDS);

        decoder.stop();
        decoder.release();
        extractor.release();
    }
}
