/**
 * Fixed version - Async MediaCodec Decoder Callback
 * Designed to avoid premature EOS and PTS=-1 issues.
 * Author: (patched by ChatGPT)
 */

class VideoDecoderCallback(
    private val extractor: MediaExtractor,
    private val lastTimestampUs: Long,
    private val onOutputEOS: (numFrames: Int, lastPts: Long) -> Unit
) : MediaCodec.Callback() {

    private val TAG = "Sum@VideoDecoderCallback"

    private val extractorLock = Any()      // Prevent race conditions
    private var eosInputSent = false       // Ensure EOS only sent once
    private var numFramesDecoded = 0
    private var lastValidPts: Long = 0     // Avoid PTS = -1

    override fun onInputBufferAvailable(codec: MediaCodec, index: Int) {
        val inputBuffer = codec.getInputBuffer(index) ?: return

        synchronized(extractorLock) {

            // 1) READ SAMPLE -------------------------------------------
            val sampleSize = extractor.readSampleData(inputBuffer, 0)

            // 2) EOS CASE ----------------------------------------------
            if (sampleSize < 0) {
                if (!eosInputSent) {
                    Log.i(TAG, "INPUT EOS reached. Send EOS buffer.")
                    codec.queueInputBuffer(
                        index, 0, 0,
                        lastValidPts,   // must NOT be -1
                        MediaCodec.BUFFER_FLAG_END_OF_STREAM
                    )
                    eosInputSent = true
                }
                return
            }

            // 3) GET PTS -----------------------------------------------
            var pts = extractor.sampleTime
            if (pts < 0) {
                Log.w(TAG, "WARNING: extractor PTS < 0. FIX to lastValidPts=$lastValidPts")
                pts = lastValidPts
            } else {
                lastValidPts = pts
            }

            // 4) NEVER force EOS by lastTimestampUs (async mode unsafe)
            // So we REMOVE: if (pts >= lastTimestampUs) send EOS

            // 5) QUEUE INPUT --------------------------------------------
            codec.queueInputBuffer(
                index,
                0,
                sampleSize,
                pts,
                extractor.sampleFlags
            )

            extractor.advance()
        }
    }

    override fun onOutputBufferAvailable(codec: MediaCodec, index: Int, info: MediaCodec.BufferInfo) {

        if ((info.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
            codec.releaseOutputBuffer(index, false)
            return
        }

        if (info.size > 0) {
            numFramesDecoded++
            lastValidPts = info.presentationTimeUs
            Log.i(TAG, "Decoded frame #$numFramesDecoded pts=$lastValidPts")
        }

        val isEOS = (info.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0
        codec.releaseOutputBuffer(index, false)

        // 6) OUTPUT EOS -----------------------------------------------
        if (isEOS) {
            Log.i(
                TAG,
                "OUTPUT EOS: totalFrames=$numFramesDecoded, lastPTS=$lastValidPts"
            )
            onOutputEOS(numFramesDecoded, lastValidPts)
        }
    }

    override fun onError(codec: MediaCodec, e: MediaCodec.CodecException) {
        Log.e(TAG, "DECODER ERROR", e)
    }

    override fun onOutputFormatChanged(codec: MediaCodec, format: MediaFormat) {
        Log.i(TAG, "Decoder output format changed: $format")
    }
}
